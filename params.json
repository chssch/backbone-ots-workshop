{"google":"","body":"### Welcome to the Introduction for Backbone, we're glad to have you.\r\n\r\nWe will build a single page app with backbone.js using a REST API. By using the backbone.js concepts of models, collections, views/sub-views, templating and routing you will learn a modern approach of designing javascript applications for the browser.\r\n\r\nWe will develop a simple bookmarking service. You can save a bookmarks (a bookmark has an descriptive name and a URL) in different folders.\r\n\r\nWe only want to develop the frontend for this. Therefore we already prepared the backend. Just install, if not done already, this ruby based API on you local machine:\r\n\r\nhttps://github.com/endor/otscamp-backbone-backend\r\n\r\nIf you need help with the installation, just let us know.\r\n\r\n### REST recap\r\n>REST stands for Representational State Transfer. (It is sometimes spelled \"ReST\".) It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.\r\n>\r\n>RESTful applications use HTTP requests to post data (create and/or update), read data (e.g., make queries), and delete data. Thus, REST uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.\r\n>http://rest.elkstein.org/\r\n\r\n\r\n\r\n# Let's start programming\r\n\r\nOpen the index.html of the public directory in your editor. You find a code skeleton for your project. To make it simple we will put every piece of code in this file. Open http://localhost:9292/ in your Chrome browser.\r\n\r\n## 1. Models\r\n\r\n>Models are the heart of any JavaScript application, containing the interactive data as well as a large part of the logic surrounding it: conversions, validations, computed properties, and access control. You extend Backbone.Model with your domain-specific methods, and Model provides a basic set of functionality for managing changes.\r\n\r\n\r\n```javascript\r\n/*\r\n* The bookmark model represents one bookmark\r\n*\r\n*/\r\nwindow.Bookmark = Backbone.Model.extend({\r\n\t\r\n    urlRoot: config.BASEURL + \"/bookmarks\",\r\n\r\n    initialize: function() {\r\n        console.log(\"Bookmark initialized\");\r\n    }\r\n\r\n});\r\n```\r\n\r\nTo start we already put this code into the model section of the index.html file. This is a basic model, that is already quite powerful because of the functionality added by the Backbone framework.\r\n\r\nOpen now the Web Inspector/Console of your Chrome browser (press Ctrl+Shift+J on Linux or Windows, press\r\nCommand+Option+J on OSX).\r\n\r\n>new Model([attributes])\r\n>\r\n>When creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.\r\n\r\nType:\r\n\r\n    var bookmark = new Bookmark({url:”http://www.opentechschool.org/”, name: “OpenTechSchool”});\r\n\r\nWe created a new bookmark instance.\r\n\r\nTo inspect the object just type into the console:\r\n\r\n    bookmark\r\n\r\nYou can find the data in the variable `attributes` of the object.\r\n\r\nLet's do some operations on the data.\r\n\r\n```\r\nbookmark.get(‘name’);\r\nbookmark.set(‘name’, ‘OTS’);\r\nbookmark.get(‘name’);\r\n```\r\nFirst we get the value of the attribute `name`. You can edit an attribute with the `set` function.\r\nWe should always use the `set` and `get` functions to change data.\r\n\r\n```\r\nbookmark.toJSON();\r\n```\r\nreturns a JSON representation of all attributes.\r\n\r\nNow we will synchronize our locally created data to the server. Watch the requests in the \"Network\" tab of your Chrome Web Inspector.\r\n\r\n```\r\nbookmark.save();\r\n```\r\n\r\nIn the \"Header\" tab you can see, that Backbone automatically wraps the data into a JSON formatted string and sends a POST request to the `/bookmark` endpoint of our API. In the \"Response\" the API returns a JSON string of the object that now has an `id`.\r\n\r\n```\r\nbookmark.id\r\n```\r\n\r\nThe bookmark is now synchronized with the server.\r\nIf you open a new tab an type\r\n\r\nhttp://localhost:9292/bookmarks (this is actually a GET request)\r\n\r\nYou get a list (as JSON) of all bookmarks stored by the backend.\r\n\r\nIf we change our model data and execute a `save()` again, we can see that Backbone is now using a PUT request to update the data on the server.\r\n\r\n## 2. Simple Views\r\n\r\n>Backbone views are almost more convention than they are code — they don't determine anything about your HTML or CSS for you, and can be used with any JavaScript templating library. The general idea is to organize your interface into logical views, backed by models, each of which can be updated independently when the model changes, without having to redraw the page. Instead of digging into a JSON object, looking up an element in the DOM, and updating the HTML by hand, you can bind your view's render function to the model's \"change\" event — and now everywhere that model data is displayed in the UI, it is always immediately up to date.\r\n\r\nWe want to create a simple view, add this code to your file.\r\n\r\n```javascript\r\nwindow.BookmarkView = Backbone.View.extend({\r\n    \r\n    initialize: function() {\r\n        console.log(\"BookmarkView initialized\");\r\n        console.log(\"Model:\", this.model);\r\n\r\n        // The $el element is automatically a cached jQuery element \r\n        // to your DOM element that you passed on view creation\r\n        console.log(\"DOM Element:\", this.$el);\r\n    },\r\n \r\n    render: function() {\r\n        this.$el.html('<b>' + this.model.get('name') + ':</b> ' \r\n                            + this.model.get('url'));\r\n        // We always return the view itself after rendering\r\n        return this;\r\n    }\r\n});\r\n```\r\n\r\nWe pass the model, that should be presented by the view, and the DOM element as options. These options are directly attached to the view:\r\n\r\n```\r\nvar bookmarkView = new BookmarkView({model: bookmark, el: \"#oneBookmark\"});\r\n```\r\n\r\nNow we can execute the `render` function:\r\n\r\n```\r\nbookmarkView.render();\r\n```\r\n\r\nThe View gets now rendered into the DOM element with the id `oneBookmark`.\r\n\r\n#### Using Templates\r\n\r\nIn the View above we're mixing presentation code with logic code (not very nice). To separate these, we use templates.\r\nUnderscore.js, a library that is used by Backbone.js comes with its own template system. We want to use that to decouple the presentational from the functional part. For more informations see also: http://underscorejs.org/#template\r\n\r\nWe're using the `<script>` tag to manage our templates. We add to the \"template section\" of our file:\r\n\r\n```\r\n<script id=\"templateBookmark\" type=\"text/html\">\r\n\t<li class=\"bookmarkEntry\">\r\n\t\t<b><%= name %></b> <a href=\"<%= url %>\"><%= url %></a>\r\n\t</li>\t\r\n</script>\r\n```\r\nWe use this template by changing our view into:\r\n\r\n```javascript\r\nwindow.BookmarkView = Backbone.View.extend({\r\n\t\r\n    // Load content of #templateBookmark and prepare template\r\n    // The underscore.js _.template funtion takes a string and \r\n    // returns a compiled template function\r\n    compiledTemplate: _.template($('#templateBookmark').html()),\r\n\r\n    // Constructor function of BookmarkView\r\n    initialize: function() {\r\n        console.log(\"BookmarkView initialized\");\r\n        this.model.on('change', this.render, this);\r\n    },\r\n\r\n    render: function() {\r\n    \t// Render template with model data\r\n    \tvar rendered = this.compiledTemplate( this.model.toJSON() ); \r\n    \t\r\n    \t// Set as inner html of view element\r\n    \tthis.$el.html(rendered);\r\n\r\n    \treturn this;\r\n    }\r\n});\r\n```\r\n\r\nReload your file and create a `Bookmark`. Pass the bookmark object and a DOM element to `BookmarkView` instance an render the view.\r\n\r\n### Events\r\n\r\nIn the view initialization we registered a event:\r\n\r\n`this.model.on('change', this.render, this);`\r\n\r\nBackbone fires different built-in events on particular actions (http://backbonejs.org/#FAQ-events). \r\n\r\nThis is what happens here: On a change of the model attached to the view, Backbone executes the `render` function of the view. We also have to pass a context `this`, so that we can use the current view in the `render` function.\r\n\r\nWe can test this function by changing the model data in the console:\r\n\r\n```\r\nbookmark.set(‘name’, ‘OTS’);\r\n```\r\n\r\nYou'll see that the content is updated in the page.\r\n\r\n## 3. Collections\r\n\r\n>Collections are ordered sets of models. You can bind \"change\" events to be notified when any model in the collection has been modified, listen for \"add\" and \"remove\" events, fetch the collection from the server.\r\n\r\nWe are going to implement a collection of bookmarks:\r\n\r\n```javascript\r\n/*\r\n* The BookmarkCollection represents a collection of bookmarks\r\n*\r\n*/\r\nwindow.BookmarkCollection = Backbone.Collection.extend({\r\n\t\r\n    // Set the url property on a collection to reference its location on the server. \r\n    url: config.BASEURL + \"/bookmarks\",\r\n\r\n    // Specify the model class that the collection contains\r\n    model: Bookmark,\r\n\r\n    initialize: function() {\r\n        console.log(\"BookmarkCollection initialized\");\r\n    }\r\n});\r\n```\r\nHave a look into the Backbone tutorial http://backbonejs.org/#Collection and play with some collection operations in your JavaScript console. Create a collection and use then the `create` function to add bookmarks to the collection and to store them on the server. Try some operations and also watch what happening in the Network tab of you Web Inspector.\r\n\r\n## 3. Collection views / Sub-Views\r\n\r\nTo display a collection of models, you can use a number of model-views as sub-views of your collection-view. Backbone doesn't regulate, how sub-views mechanics should be implemented. In our simple approach, we implement a parent-View (the `BookmarkCollectionView`) that renders all sub-views in its own render function.\r\n\r\n```javascript\r\n/*\r\n* The BookmarkCollectionView represents the user interface to list and manipulate \r\n* a collection of bookmarks\r\n*\r\n*/\r\nwindow.BookmarkCollectionView = Backbone.View.extend({\r\n    // Constructor function of BookmarkView\r\n    initialize: function() {\r\n        console.log(\"BookmarkCollectionView initialized\");\r\n        // Re-render if a element is removed or the collection is synced with the server\r\n        this.collection.on('remove', this.render, this);\r\n        this.collection.on('sync', this.render, this);    \r\n    },\r\n\r\n    // The render function renders the View into a given DOM element\r\n    render: function() {\r\n        \r\n        var self = this;\r\n\r\n        // Clear DOM element\r\n        this.$el.empty();\r\n         \r\n        // Create a subview for every collection element and render this suview\r\n        // Append this subview element to the parent view\r\n        this.collection.each(function(model) {\r\n            var bookmarkView = new BookmarkView({model: model});\r\n            self.$el.append(bookmarkView.render().el);\r\n        });\r\n    },\r\n    \r\n    // Define events\r\n    events: {\r\n        // If .delete is clicked, execute the delete function of this view\r\n        'click .delete': 'delete',\r\n    },\r\n    \r\n    delete: function(event) {   \r\n        var bookmark = this.collection.get($(event.currentTarget).data('bookmark-id'));  \r\n        console.log(\"Delete bookmark\", bookmark);\r\n        this.collection.remove(bookmark);\r\n        bookmark.destroy();\r\n    }\r\n});\r\n```\r\n\r\nIn the bottom of the file you can bootstrap some objects to use. You should already have some bookmarks stored in the backend. So, just use fetch to request your bookmark.\r\n\r\n```javascript\r\n\r\n  // Create a collection \r\n  var collection = new BookmarkCollection();\r\n  collection.fetch();\r\n \r\n  // Create a collectionView for a list of bookmarks\r\n  var bookmarkCollectionView = new BookmarkCollectionView({collection: collection, el: \"#bookmarkList\"});\r\n  bookmarkCollectionView.render();\r\n\r\n```\r\n\r\nChange the first element of the collection:\r\n\r\n```\r\ncollection.at(0).set('name', 'NewName')\r\n```  \r\n\r\nThe first element in the list of the web page should change now. The events bound to the model view before, are still working.\r\n\r\n## Extend our application\r\n\r\nIn the next steps you can implement the logic for the folders. Feel free to write some code by you own:\r\n\r\n1. Implement a `Folder` model for a folder\r\n2. Implement a `FolderCollectionView` that displays a list of all folder names. The view should contain a input element, where i can type a name and create a new folder.\r\n3. If I click on a folder, i should get displayed all bookmarks of that folder. \r\n \r\n## More topics\r\n\r\nIf we still have time we can speak about:\r\n\r\n1. How to structure the application, how to divide it into several files\r\n2. How to test our code\r\n3. How to use other template frameworks\r\n\r\n### Authors and Contributors\r\nFrank ...\r\nChristoph Schwienheer, @chssch","name":"Backbone-ots-workshop","tagline":"A backbone workshop","note":"Don't delete this file! It's used internally to help with page regeneration."}